use std::sync::Arc;

use async_trait::async_trait;
use ractor::Actor;
use serde::{Deserialize, Serialize};
use thiserror::Error;

use super::bank_events::BankAccountEvent;
extern crate ask_cqrs;

#[derive(Debug, Clone)]
pub enum BankAccountCommand {
    OpenAccount { user_id: String },
    DepositFunds { amount: i32 },
    WithdrawFunds { amount: i32 },
    ChangeOwner { user_id: String },
    // Define your command structure
}

#[derive(Debug, Default, Clone)]
pub struct BankAccountState {
    user_id: String,
    balance: i32,
}

#[derive(Debug, Error)]
pub enum BankAccountError {
    #[error("EventStore error: {0}")]
    EventStore(#[from] eventstore::Error),

    #[error("Serde error: {0}")]
    Serde(#[from] serde_json::Error),
    #[error("Insufficient funds")]
    NotEnoughFunds,

    #[error("Account already exists")]
    AlreadyOpened,

    #[error("Account not found")]
    AccountNotFound,
}

pub struct BankAccountAggregate;

impl ask_cqrs::aggregate::Aggregate for BankAccountAggregate {
    type Event = BankAccountEvent;
    type Command = BankAccountCommand;
    type DomainError = BankAccountError;
    type State = BankAccountState;

    fn apply_event(state: Option<Self::State>, event: &Self::Event) -> Self::State {
        match state {
            None => match event {
                BankAccountEvent::AccountOpened { user_id, balance } => BankAccountState {
                    balance: *balance,
                    user_id: user_id.to_string(),
                },
                _ => panic!("Account not found"),
            },

            Some(s) => match event {
                BankAccountEvent::FundsDeposited { amount } => BankAccountState {
                    balance: s.balance + amount,
                    ..s
                },
                BankAccountEvent::FundsWithdrawn { amount } => BankAccountState {
                    balance: s.balance - amount,
                    ..s
                },
                BankAccountEvent::OwnerChanged { user_id } => BankAccountState {
                    user_id: user_id.clone(),
                    ..s
                },
                _ => panic!("Account not found"),
            },
        }
    }

    fn execute(
        state: &Option<Self::State>,
        command: &Self::Command,
    ) -> Result<Vec<Self::Event>, Self::DomainError> {
        let event = match state {
            Some(state) => match command {
                BankAccountCommand::OpenAccount { user_id } => Err(BankAccountError::AlreadyOpened),
                BankAccountCommand::DepositFunds { amount } => {
                    Ok(BankAccountEvent::FundsDeposited { amount: *amount })
                }
                BankAccountCommand::ChangeOwner { user_id } => Ok(BankAccountEvent::OwnerChanged {
                    user_id: user_id.clone(),
                }),
                BankAccountCommand::WithdrawFunds { amount } => {
                    if state.balance < *amount {
                        Err(BankAccountError::NotEnoughFunds)
                    } else {
                        Ok(BankAccountEvent::FundsWithdrawn { amount: *amount })
                    }
                }
            },
            None => match command {
                BankAccountCommand::OpenAccount { user_id } => {
                    Ok(BankAccountEvent::AccountOpened {
                        user_id: user_id.clone(),
                        balance: 0,
                    })
                }
                _ => Err(BankAccountError::AccountNotFound),
            },
        }?;
        Ok(vec![event])
    }

    fn name() -> &'static str {
        "BankAccountAggregate"
    }
}
